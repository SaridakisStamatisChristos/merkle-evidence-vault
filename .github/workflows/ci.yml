name: CI

on:
  push:
    branches: [ main, '**' ]
  pull_request:
    branches: [ main ]

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure a go.sum exists for cache step
        run: |
          # If there are no go.sum files in the repository, create an empty placeholder
          # so the cache action doesn't warn about a missing dependencies file.
          shopt -s globstar || true
          found=$(ls -1 **/go.sum 2>/dev/null | wc -l || true)
          if [ "$found" -eq "0" ]; then
            echo "No go.sum found in workspace; creating placeholder go.sum"
            touch go.sum
          else
            echo "Found $found go.sum file(s); using those for cache key"
          fi

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Run gofmt
        run: |
          gofmt -l . | tee /tmp/gofmt.out || true
          if [ -s /tmp/gofmt.out ]; then
            echo "Files not gofmt'd:"; cat /tmp/gofmt.out; exit 1
          fi

      - name: Run go vet per module
        run: |
          # Find all directories containing a go.mod and run `go vet` inside them.
          set -e
          echo "Scanning repository for go.mod files..."
          find . -name go.mod -not -path "./.git/*" | while read -r mod; do
            dir=$(dirname "$mod")
            # skip the top-level tests module; it contains integration/e2e suites
            case "$dir" in
              ./tests*)
                echo "Skipping vet in $dir";
                continue;
                ;;
            esac
            echo "Running go vet in: $dir"
            (cd "$dir" && go vet ./...)
          done

      - name: Run unit tests per module
        run: |
          # Find module roots (go.mod) and run tests inside each module
          set -e
          echo "Scanning repository for go.mod files to run tests..."
          find . -name go.mod -not -path "./.git/*" | while read -r mod; do
            dir=$(dirname "$mod")
            # skip the tests module during lint step; it will be exercised later
            case "$dir" in
              ./tests*)
                echo "Skipping tests in $dir";
                continue;
                ;;
            esac
            echo "Running go test in: $dir"
            (cd "$dir" && go test ./... -count=1 -v)
          done

      - name: Set up Node.js for frontend tests
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run frontend unit tests
        working-directory: frontend/audit-dashboard
        run: |
          # Prefer reproducible `npm ci`; fall back to `npm install` if lockfile and package.json diverge.
          if npm ci --prefer-offline --no-audit --no-fund; then
            echo "npm ci succeeded"
          else
            echo "npm ci failed, falling back to npm install"
            npm install --no-audit --no-fund
          fi
          npm test --silent

  integration-e2e:
    runs-on: ubuntu-latest
    needs: lint-and-test
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Start Go JWKS stub server and generate tokens
        run: |
          # Start the Go-based JWKS stub; it writes its own env file and emits logs.
          # Redirect stdout/stderr to a separate log so the env file stays clean.
          nohup go run scripts/ci_jwks.go > /tmp/ci_jwks.log 2>&1 &

          # Wait for the stub to write scripts/ci_jwks_env.txt so later steps
          # that read it won't fail. If the file does not appear, dump the
          # stub log to help debugging and fail the job early.
          for i in {1..30}; do
            if [ -f scripts/ci_jwks_env.txt ]; then
              echo "Found scripts/ci_jwks_env.txt"
              break
            fi
            sleep 1
          done
          if [ ! -f scripts/ci_jwks_env.txt ]; then
            echo "ERROR: scripts/ci_jwks_env.txt not found after waiting";
            echo "=== /tmp/ci_jwks.log ===";
            if [ -f /tmp/ci_jwks.log ]; then
              tail -n +1 /tmp/ci_jwks.log || true
            fi
            exit 1
          fi

      # vault-api will be started by the integration helper after JWKS and
      # dependency services are ready. Do not start it here to avoid a race
      # where the server observes no JWKS_URL/ENABLE_TEST_JWT and rejects
      # requests with 401.

      - name: Load CI envs and persist to environment
        shell: bash
        run: |
          # wait for JWKS stub to write its environment file
          for i in {1..15}; do
            if [ -f scripts/ci_jwks_env.txt ]; then break; fi
            sleep 1
          done
          set -o allexport
          # load variables into this shell for local use (not strictly necessary)
          while IFS= read -r line; do
            export "$line"
          done < <(grep -E '^[A-Z0-9_]+=.*' scripts/ci_jwks_env.txt | sed 's/\r$//')
          set +o allexport
          # persist for all following steps
          grep -E '^[A-Z0-9_]+=.*' scripts/ci_jwks_env.txt >> $GITHUB_ENV
      - name: Run integration helper (use JWKS stub for real verification)
        shell: bash
        run: |
          pwsh -NoProfile -ExecutionPolicy Bypass -File ./scripts/run-integration.ps1 -EnableTestJwt:$false -ApiUrl "http://localhost:8080"

      - name: CI cleanup JWKS artifacts
        run: |
          echo "Cleaning up CI JWKS artifacts"
          rm -f scripts/ci_jwks_env.txt || true
